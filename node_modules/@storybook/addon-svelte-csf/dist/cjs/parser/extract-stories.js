"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractStories = extractStories;

var _tsDedent = _interopRequireDefault(require("ts-dedent"));

var svelte = _interopRequireWildcard(require("svelte/compiler"));

var _extractId = require("./extract-id");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function getStaticAttribute(name, node) {
  // extract the attribute
  var attribute = node.attributes.find(function (att) {
    return att.type === 'Attribute' && att.name === name;
  });

  if (!attribute) {
    return null;
  }

  var value = attribute.value; // expect the attribute to be static, ie only one Text node

  if (value && value.length === 1 && value[0].type === 'Text') {
    return value[0].data;
  }

  throw new Error("Attribute ".concat(name, " is not static"));
}
/**
 * Parse a Svelte component and extract stories.
 * @param component Component Source
 * @returns Map of storyName -> source
 */


function extractStories(component) {
  // compile
  var _svelte$compile = svelte.compile(component),
      ast = _svelte$compile.ast;

  var allocatedIds = ['default'];
  var localNames = {
    Story: 'Story',
    Template: 'Template'
  };
  svelte.walk(ast.instance, {
    enter: function enter(node) {
      if (node.type === 'ImportDeclaration') {
        if (node.source.value === '@storybook/addon-svelte-csf') {
          node.specifiers.filter(function (n) {
            return n.type === 'ImportSpecifier';
          }).forEach(function (n) {
            localNames[n.imported.name] = n.local.name;
          });
        }

        this.skip();
      }
    }
  }); // extracts allocated Ids

  svelte.walk(ast.instance, {
    enter: function enter(node) {
      if (node.type === 'ImportDeclaration') {
        node.specifiers.map(function (n) {
          return n.local.name;
        }).forEach(function (name) {
          return allocatedIds.push(name);
        });
        this.skip();
      }
    }
  });
  var stories = {};
  svelte.walk(ast.html, {
    enter: function enter(node) {
      if (node.type === 'InlineComponent' && (node.name === localNames.Story || node.name === localNames.Template)) {
        this.skip();
        var isTemplate = node.name === 'Template'; // extract the 'name' attribute

        var name = getStaticAttribute('name', node); // templates has a default name

        if (!name && isTemplate) {
          name = 'default';
        }

        var id = (0, _extractId.extractId)({
          id: getStaticAttribute('id', node),
          name: name
        }, isTemplate ? undefined : allocatedIds);

        if (name && id) {
          // ignore stories without children
          var source;

          if (node.children.length > 0) {
            var start = node.children[0].start;
            var end = node.children[node.children.length - 1].end;
            source = (0, _tsDedent["default"])(component.substr(start, end - start));
          }

          stories[isTemplate ? "tpl:".concat(id) : id] = {
            name: name,
            template: isTemplate,
            source: source,
            hasArgs: node.attributes.find(function (att) {
              return att.type === 'Let';
            }) != null
          };
        }
      }
    }
  });
  return {
    stories: stories,
    allocatedIds: allocatedIds
  };
}