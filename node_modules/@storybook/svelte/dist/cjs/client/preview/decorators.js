"use strict";

require("core-js/modules/es.object.keys.js");

require("core-js/modules/es.symbol.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decorateStory = decorateStory;

require("core-js/modules/es.array.reduce.js");

require("core-js/modules/es.object.assign.js");

var _SlotDecorator = _interopRequireDefault(require("./SlotDecorator.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var defaultContext = {
  id: 'unspecified',
  name: 'unspecified',
  kind: 'unspecified',
  parameters: {},
  args: {},
  argTypes: {},
  globals: {}
};
/**
 * Check if an object is a svelte component.
 * @param obj Object
 */

function isSvelteComponent(obj) {
  return obj.prototype && obj.prototype.$destroy !== undefined;
}
/**
 * Handle component loaded with esm or cjs.
 * @param obj object
 */


function unWrap(obj) {
  return obj && obj.default ? obj.default : obj;
}
/**
 * Transform a story to be compatible with the PreviewRender component.
 *
 * - `() => MyComponent` is translated to `() => ({ Component: MyComponent })`
 * - `() => ({})` is translated to `() => ({ Component: <from parameters.component> })`
 * - A decorator component is wrapped with SlotDecorator. The decorated component is inject through
 * a <slot/>
 *
 * @param context StoryContext
 * @param story  the current story
 * @param originalStory the story decorated by the current story
 */


function prepareStory(context, story, originalStory) {
  var result = unWrap(story);

  if (isSvelteComponent(result)) {
    // wrap the component
    result = {
      Component: result
    };
  }

  if (originalStory) {
    // inject the new story as a wrapper of the original story
    result = {
      Component: _SlotDecorator.default,
      props: {
        decorator: unWrap(result.Component),
        decoratorProps: result.props,
        component: unWrap(originalStory.Component),
        props: originalStory.props,
        on: originalStory.on
      }
    };
  } else {
    var cpn = result.Component;

    if (!cpn) {
      // if the component is not defined, get it from parameters
      cpn = context.parameters.component;
    }

    result.Component = unWrap(cpn);
  }

  return result;
}

function decorateStory(storyFn, decorators) {
  return decorators.reduce(function (previousStoryFn, decorator) {
    return function () {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultContext;
      var story;
      var decoratedStory = decorator(function () {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var parameters = _ref.parameters,
            innerContext = _objectWithoutProperties(_ref, ["parameters"]);

        story = previousStoryFn(Object.assign({}, context, innerContext));
        return story;
      }, context);

      if (!story) {
        story = previousStoryFn(context);
      }

      if (!decoratedStory || decoratedStory === story) {
        return story;
      }

      return prepareStory(context, decoratedStory, story);
    };
  }, function (context) {
    return prepareStory(context, storyFn(context));
  });
}